from openai import OpenAI
import json 
from typing import Dict 
import logging
import os
from tqdm import tqdm

from src.rag.queries import ai_query, sdg_query

logger = logging.getLogger(__name__)
logging.basicConfig(
    filename=os.path.join("src", "rag", "classifier.log"),
    level=logging.INFO,
    filemode='w'
)

class Classify():

    """
    Classify the retrieved passages based on AI/SDG query
    """

    def __init__(self, json_path: str):
        """
        Args:
            json_path: Path to the JSON file containing retrieved passages
        """
        with open(json_path, 'r') as f:
            self.json_data = json.load(f)


    @staticmethod
    def validate_response(response: str) -> bool:
        """
        Validate response from the Client

        Args:
            response: Response generated by the LLM Client, processed as a string
        """

        response = response.strip()
        if response.lower() == "yes" or response.lower() == "no":
            return True
        else:
            return False


    def classify(self, input_prompt: str, model: str = "gpt-4o-mini", client: OpenAI = OpenAI()):
        """
        A base method to prompt GPT models, and get classifications for the passages

        Args:
            input_prompt: Prompt sent to teh LLM client
            model: OpenAI model name
            client: OpenAI client

        Returns:
            string response from the LLM
        """

        completion = client.chat.completions.create(
            model=model,
            messages=[
                {"role": "system", "content": ""},
                {
                    "role": "user",
                    "content": input_prompt
                }
            ]
        )

        return completion.choices[0].message.content
    
    def generate_response(self, query):
        """
        Generate a response from LLM based on input ai/sdg query including retries
        Logging every response 

        Returns:
            parsed_response: Response after validation
        """

        response = self.classify(input_prompt=query)

        ## Response Validation 
        if self.validate_response(response):
            return response
        else:
            # Retry for 3 attempts
            attempt = 1
            success = 0
            while attempt <= 3:
                response = self.classify(input_prompt=query)
                if self.validate_response(response):
                    return response
                else:
                    attempt += 1
            if not success:
                logger.info(f"Failed to generate a valid response.\nGenerated Response - {response}")
                return response
                    
    
    def get_classifications(self) -> Dict:
        """
        Append response from LLM to the json object from retrieved docs
        
        Returns:
            classifications: Dict containing ai flag and sdg flag based on response from the LLM
        """

        classifications = []
        for json_obj in tqdm(self.json_data):
            ai_q = ai_query(sub_target=json_obj["sub_target"], extracted_passage=json_obj["page_content"])
            ai_response = self.generate_response(ai_q)
            sdg_q = sdg_query(sub_target=json_obj["sub_target"], extracted_passage=json_obj["page_content"])
            sdg_response = self.generate_response(sdg_q)

            # Rebuild over json object
            classification_obj = {
                "goal": json_obj["goal"],
                "sub_target": json_obj["sub_target"],
                "passage": json_obj["page_content"],
                "ai": ai_response,
                "sdg": sdg_response
            }

            classifications.append(classification_obj)
        
        return classifications


if __name__=='__main__':

    RET_DIR = os.path.join("results", "retrieve")

    for company in os.listdir(RET_DIR):
        if os.path.isdir(os.path.join(RET_DIR, company)):
            years = os.listdir(os.path.join(RET_DIR, company))
            for y in tqdm(years, desc=f"Classifications for {company}"):
                if os.path.isdir(os.path.join(RET_DIR, company, y)):
                    retrieved_json = os.path.join(RET_DIR, company, y, "passages.json")

                    classifier = Classify(retrieved_json)
                    classifications = classifier.get_classifications()

                    save_path = os.path.join(RET_DIR, company, y, "classifications.json")
                    with open(save_path, 'w') as f:
                        json.dump(classifications, f, indent=4)

    